\documentclass[a4paper,12pt]{report}

\usepackage{alltt, fancyvrb, url}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{float}
\usepackage{hyperref}

\usepackage[italian]{babel}

\usepackage[italian]{cleveref}

\title{''Ralph Spaccatutto''}

\author{Enrico Cornacchia \\ Giulia Golesano \\ Giovanni Rinchiuso \\ Nikolai Zanni}
\date{10 giugno 2024}

\begin{document}

\maketitle

\tableofcontents

\chapter{Analisi}

\section{Requisiti}

Il progetto si pone l'obbiettivo di ricreare un videogioco basato sul classico e celebre arcade Ralph Spaccatutto, che rientra nella categoria dei giochi platformer, ossia dei giochi in cui la meccanica di gioco implica l'attraversamento di uno o piu livelli, ognuno dei quali è composto da piattaforme solitamente situate su più piani.

\subsection{Requisiti funzionali}

\begin{itemize}

	\item Felix, il protagonista del gioco, avrà l'obiettivo di aggiustare tutte le finestra del condominio, rotte dall'antagonista Ralph. 
	\item Per arrivare a tale scopo, potrà muoversi a destra e a sinistra lungo ogni piattaforma, che rappresenta un piano del condominio, per poi salire o scendere agli altri piani.
	\item Una complicazione che incontrerà il protagonista sono i mattoni che, durante tutta la partita, Ralph lancerà dalla sua piattaforma in cima al condominio.
 \item Felix  dovrà schivare i mattoni per non perdere le sue 3 vite a disposizione.
	\item Degli aiuti che potrà ottenere sono invece i power ups che gli potranno garantire invincibilità per qualche secondo.
	\item I nostri requisiti funzionali prevedono, oltre al corretto funziamento del gioco, un menù iniziale da cui selezionare l'avvio, la pausa o l'arresto del gioco, tramite appositi tasti.
\end{itemize}

\subsubsection{Requisiti non funzionali}
\begin{itemize}
	\item Ci poniamo l'obiettivo di fornire un'esperienza di gioco il più fluida possibile, restando sempre fedeli alla versione originale nonostante le nostre rivisitazioni.
\end{itemize}

\section{Analisi e modelli del dominio}
La schermata di gioco è composta da una facciata di condominio, simile ad una griglia, in cui si trovano alcune file di finestre, alcune intere e alcune rotte, in base alla difficoltà del livello.
Come anticipatamente spiegato, il player Felix dovrà aggiustare tutte le finestre, schivando i mattoni lanciati da Ralph, per vincere la partita.
Per farlo, dovrà fermarsi, davanti alla finestra che desidera aggiustare, e tenere premuto il Z per 1.5 secondi. 
Per muoversi tra i piani avrà a disposizione le 4 direzioni UP, DOWN, LEFT e RIGHT, ognuna svolta dalle lettere W,S,A e D.
Felix avrà un numero limitato di vite, che di default sarà 3, che potrà perdere se colpito da uno dei mattoni lanciati da Ralph, con successivo ritorno alla piattaforma di partenza, senza che si annullino i progressi della partita.
Durante il gioco saranno possibili power ups che permetteranno a Felix di ricevere aiuti extra.


\begin{figure}[H]
\includegraphics[width=1\textwidth]{img/analisi.png} 
\centering{}
\caption{Schema UML dell'analisi del problema, con rappresentate le entità principali ed i rapporti fra loro}
\label{img:analisi}
\end{figure}

\chapter{Design}

\section{Architettura}
Per realizzare il progetto abbiamo adottato il pattern architetturale MVC (Model-View-Controller) rispettando il più possibile tale suddivisione. 
Ogni suddivisione gestisce una parte diversa: "model” gestisce la logica e i dati del gioco, “view” gestisce la parte grafica, che in base allo stato di gioco (menu, playing, settings, win, death. . . ) disegnera la corretta finestra, infine “controller” ha il compito di interporsi tra model e view per permetterne la comunicazione. 
Abbiamo inoltre scelto di adottare il pattern ECS (Entity-Component System) per la parte di Model, in particolare ogni oggetto di gioco é un’entita che può essere composta da component, ognuno dei quali descrive uno specifico comportamento. 

\begin{figure}[H]
\centering{}
\includegraphics[width=1.25\textwidth]{img/architettura.png}
\caption{Schema UML architetturale di DonkeyKong.}
\label{img:architettura}
\end{figure}

\section{Design dettagliato}
\subsection{Nikolai Zanni}

\subsubsection{Implementazione del menù}

\begin{figure}[H]
\centering{}
\includegraphics[width=\textwidth]{img/menu.png}
\caption{Rappresentazione UML della gestione MVC per il menu.}
\end{figure}

\paragraph{Problema:}
Il gioco possiede un menù iniziale dal quale è possibile avviare una partita, modificare le impostazioni, scegliere un livello o uscire dal gioco.

\paragraph{Soluzione:}
Stati e View già caricati con l'esecuzione del gioco. Quando viene chiamato draw() all’interno della view saranno disegnati tutti gli elementi grafici dell’attuale stato di gioco, per esempio trovandoci nel menu, il background eccetera. Quando si ottiene un input che sia da mouse o da tastiera, in questo caso per ora solo il primo (il secondo `e messo in vista di implementazioni future) in base al bottone che viene premuto sar`a notificato al controller uno stato da applicare che sar`a passato al model e poi eseguito. In caso il bottone premuto fosse quello che poi ci porta all’inizio di una partita allora sar`a settato di default il livello uno, quello considerato iniziale, tramite le chiamate setLevel() e avviata la partita tramite startGame().

\subsubsection{Scelta dei livelli}

\begin{figure}[H]
\centering{}
\includegraphics[width=\textwidth]{img/levels.png}
\caption{Rappresentazione UML della gestione della scelta dei livelli.}
\end{figure}

\paragraph{Problema:}
Nel menu di scelta dei livelli è possibile tornare al menu oppure scegliere un livello.

\paragraph{Soluzione:}
Come per il Menu, in questa schermata `e possibile iniziare una partita, la differenza risiede nel fatto che sono presenti quattro pulsanti diversi (escluso quello per tornare al menu che `e uguale in tutte le schermate) che ci permettono di iniziare quattro livelli unici. Quando la view riceve un punto premuto dal mouse, se `e stato premuto un pulsante che fa iniziare la partita, viene controllato quale deve essere impostato e inviato al menu. che tramite handleChoosenLevel(CurrentLevel level) lo passa al model che esegue il setLevel(CurrentLevel level). Notiamo in questo caso che a differenza del menu, i metodi sopra citati lavorano con un parametro CurrentLevel (enum per la gestione dei livelli) dato che abbiamo la scelta; ovviamente viene anche chiamato il metodo startGame().

\subsubsection{Gestione del settings}

\begin{figure}[H]
\centering{}
\includegraphics[width=\textwidth]{img/settings.png}
\caption{Rappresentazione UML della gestione del settings.}
\end{figure}

\paragraph{Problema:}
Quando ci ritroviamo nella schermata delle impostazioni `e possibile tornare al menu, modificare l’audio disattivandolo o attivandolo e cambiare musica di sottofondo.

\paragraph{Soluzione:}
Prettamente simile a quella del Menu, ma con differenza che da questa schermata non ci `e permesso avviare una partita; semplicemente quando la view ricever`a un punto premuto dal mouse, se sar`a sopra un buttone verr`a applicato lo stato di riferimento, in caso della pressione dei pulsante di gestione audio, sar`a effettuata l’azione corretta.

\subsubsection{Gestione della schermata finale e di pausa}

\begin{figure}[H]
\centering{}
\includegraphics[width=\textwidth]{img/end_stop.png}
\caption{Rappresentazione UML della schermata finale e pausa.}
\end{figure}

\paragraph{Problema:}
Nella schermata di pausa `e possibile ritornare al gioco menu, mentre in quella di fine, ovvero vittoria o sconfitta `e possibile ricominciare il livello da capo. In entrambe `e possibile tornare al menu.

\paragraph{Soluzione:}
Il pulsante per il Menu funziona come per le altre schermate, in questo caso durante lo sviluppo mi sono reso conto che le schermate erano praticamente tutte identiche, di conseguenza ho deciso di controllare lo stato in cui mi trovo all’interno del draw() in modo da visualizzare solo gli elementi grafici corrispondenti. Il metodo startGame() viene utilizzato quando ci si trova nella schermata di fine, mentre in quella di pausa si procede semplicemente riprendendo la partita in corso. Quando ci si trova nella schermata di pausa sono presenti le stesse impostazioni audio della schermata Settings, semplicmente in questa schermata potremo scegliere tra due musiche di gioco diverse da quelle di menù.

\subsubsection{Gestione dei power ups}

\begin{figure}[H]
\centering{}
\includegraphics[width=\textwidth]{img/power_ups.png}
\caption{Rappresentazione UML della gestione dei power ups.}
\end{figure}

\paragraph{Problema:}
Il giocatore deve poter usufruire di eventuali powerup sparsi per la mappa i quali forniscono potenziamenti. Anche i barili possono avere powerup, come il danno doppio.

\paragraph{Soluzione:}
Ho deciso di creare un component per ogni powerup, in modo da ottenere una gestione semplice, efficace e facilmente estendibile, ognuno di essi eredita update() da AbstractComponent sfruttando il Template MethodPattern. Ognuno di essi ha un metodo set e get: tramite il primo impostiamo lo stato del power up, il secondo ci ritorna lo stato stesso. Si nota che tra i power up presenti c’`e anche SlowComponent, il quale per`o non viene mai effettivamente utilizzato, questo perch`e `e stato inserito in vista futura. In ogni caso per poterlo utilizzare basterebbe semplicemente aggiungerlo ad un entità.


\subsection{Cornacchia Enrico}

\subsubsection{Gestione di entità}

\begin{figure}[H]
\centering{}
\includegraphics[width=\textwidth]{img/entities.png}
\caption{Rappresentazione UML dell'implementazione delle entità.}
\end{figure}

\paragraph{Problema:}
Nel contesto di un gioco, le entità sono elementi centrali e la loro gestione deve essere efficiente. In particolare, è comune che diverse entità condividano comportamenti simili o identici, il che può portare a duplicazione di codice. 

\paragraph{Soluzione:}
Per affrontare il problema della duplicazione di codice e gestire in modo efficiente le entità, ho adottato il Composite pattern. In questo approccio, ogni entità è rappresentata da una singola classe, con enumeratore che ne identifica la tipologia. Questa classe può essere vista come un contenitore vuoto che può essere arricchito con vari componenti durante la sua creazione. Questi componenti, che rappresentano comportamenti o caratteristiche specifiche, possono essere combinati in vari modi per creare entità diverse. Questo rende il codice più modulare, facilita le modifiche e le estensioni, e promuove il riutilizzo del codice. 

\subsubsection{Creazione di nuove entità}

\begin{figure}[H]
\centering{}
\includegraphics[width=\textwidth]{img/entity_factory.png}
\caption{Rappresentazione UML della creazione di entità.}
\end{figure}

\paragraph{Problema:}
Sia in fase di avvio del gioco che nel corso dello stesso, è indispensabile generare varie entità, ciascuna con diversi componenti, a seconda dei comportamenti definiti per ciascuna.

\paragraph{Soluzione:}
Ho, quindi, usato il Factory pattern visto che permette di generare nuove istanze di entità in maniera centralizzata, ognuna diversa e con componenti vari, in modo relativamente veloce e semplice. Ciò comporta numerosi benefici, tra cui la separazione della logica di creazione delle entità dal resto dell'applicazione, rendendo il codice più modulare. Inoltre, in futuro, se fosse necessario modificare la creazione, i parametri o i componenti di una o più entità, ciò potrebbe essere fatto con maggiore facilità. La factory può accettare parametri in ingresso per la creazione di queste entità, come ad esempio la posizione o lo stato iniziale. In alternativa si sarebbe potuto usare anche il Builder Pattern, tuttavia le entità in questo gioco non richiedono particolari passaggi per la loro creazione e avere classi builder per ogni tipo di entità renderebbe complesso il codice più di quanto sia necessario in questo caso.

\subsubsection{Gestione delle collisioni tra entità}

\begin{figure}[H]
\centering{}
\includegraphics[width=\textwidth]{img/collisions.png}
\caption{Rappresentazione UML della gestione delle collisioni tra entità.}
\end{figure}

\paragraph{Problema:}
Come gestire le collisioni tra le varie entità in modo dinamico, permettendo quindi aggiunte e rimozioni di entità di varie tipologie e cambiamenti di stato.

\paragraph{Soluzione:}
Per poter gestirle ho scelto un pattern Observer che permette di cambiare stato di certe entità Observer a seconda di una collisione o no tramite l'observable CollisionManager e se vengono introdotte nuove entità, la classe CollisionManager ha in suo possesso già il nuovo insieme. Ciò permette anche la creazione in futuro di altre entità, con caratteristiche nuove, senza dover cambiare la classe CollisionManager, ma bisogna aggiungere le nuove interazioni tra le nuove tipologie di entità e le preesistenti all'interno del metodo update() della classe HitboxComponent. In particolare, in quest'ultima classe lo Strategy pattern sarebbe potuto essere utilizzato nella gestione delle varie casistiche di collisione, permettendo di creare delle ulteriori componenti che gestiscono le collisioni tra certe entità, facilitando anche la gestione, ad esempio, di casi particolari come la collisione tra le entità finestra e Felix.


\subsection{Golesano Giulia}

\subsubsection{Gestione della schermata di gioco }

\begin{figure}[H]
\centering{}
\includegraphics[width=\textwidth]{img/game.png}
\caption{Rappresentazione UML della gestione della schermata di gioco.}
\end{figure}

\paragraph{Problema:}
Gestione della schermata di gioco: inserimento, eliminazione e controllo di ogni entità presente sul campo di gioco, con successiva rappresentazione grafica di esse.
Implementazione di classi View per ogni entità, cosi da realizzare animazioni e aggiungere gli elementi grafici del gioco.

\paragraph{Soluzione:}
Ho creato un'interfaccia GamePerformance e una implementazione GamePerformanceImpl.
Queste classi sono importanti perché fanno un "resoconto" di tutti gli elementi che si riconducono al Model del progetto, cosi da permettere alle classi di View e Controller di accedervi da li.
Ho realizzato un'interfaccia View, che per ogni entità, cerchi l'immagine tra le risorse, realizzi l'animazione o estrapoli il frame desiderato del png.
Ogni componente del gruppo successivamente, per realizzare la grafica dei propri elementi, si è appoggiato a tale interfaccia per mantenere un ordine di implementazione simile.

\subsubsection{Gestione degli input }

\begin{figure}[H]
\centering{}
\includegraphics[width=\textwidth]{img/input.png}
\caption{Rappresentazione UML della gestione listener generici di input da tastiera e mouse.}
\end{figure}

\paragraph{Problema:}
Per giocare è necessario far muovere il giocatore sulla schermata di gioco, cliccare sui pulsanti e premere i tasti giusti per aggiustare le finestre.

\paragraph{Soluzione:}
La classe principale che si occupa di tale compito è WindowGame, che contiene la scena principale del gioco, alla quale si appoggiano gli input, grazie al metodo di Javafx setOnKeyPressed e setOnKeyRealeased.
Tale input, una volta riconosciuto, passa attraverso il controller generico per raggiungere quello desiderato, che compierà l'azione richiesta dallo specifico tasto.

\subsubsection{Creazione delle finestre}

\begin{figure}[H]
\centering{}
\includegraphics[width=\textwidth]{img/windows.png}
\caption{Rappresentazione UML della gestione delle collisioni.}
\end{figure}

\paragraph{Problema:}
Il campo di gioco si compone principalmente da una griglia di 3x5 finestre, ognuna delle quali è un'entità a se stante, con la caratteristica di essere integra o rotta, a inizio partita.

\paragraph{Soluzione:}

Ho realizzato le classi WindowsController, FixWindowsComponent, FixedWindowsComponent e WindowsView per la gestione di questo problema. 
I component  si occupano di conferire alle entità la capacità di aggiustare finestre e la capacità di essere aggiustate.
FixWindowsComponent, associato all'entità Felix, si occupa di ricercare la finestra che sta entrando in collisione con Felix, e tramite la sua posizione, impostare il suo campo booleano a True.
FixedWindowsComponent, associato ad ogni finestra in maniera indipendente, si occupa della gestione di questo booleano.
La classe principale che si occupa della schermata di gioco WindowGame, dopo controllato il livello, richiama WindowsController, che ha il compito di creare la griglia di finestre e controllare le condizioni di vittoria.
Poi, di nuovo WindowGame, seguendo la griglia appena creata, richiama ogni WindowsView.



\subsection{Rinchiuso Giovanni}

\subsubsection{Gestione del GameEngine}

\begin{figure}[H]
\centering{}
\includegraphics[width=\textwidth]{img/gameloop.jpg}
\caption{Rappresentazione UML del game engine.}
\end{figure}

\paragraph{Problema} Il gioco deve essere in grado di permettere un gameplay fluido senza lag, aggiornando ciclicamente la grafica (view) e la logica di gioco (model) in contemporanea.

\paragraph{Soluzione} Ho deciso di scorporare la gestione del game loop dal controller principale (GameController) implementando un’interfaccia GameEngine, al fine di evitare la condivisione di codice sensibile e garantire una maggiore indipendenza, permettendo così di estendere anche in altre classi, in caso di bisogno, il motore del gioco. All'avvio del gioco viene richiamato il metodo start() di WindowGame, che dopo aver disegnato la schermata principale, utilizza la classe AnimationTimer e più in particolare il suo metodo handle(long now), per ciclare ed eseguire il metodo gameLoop() di GameEngine. Tuttavia, durante lo sviluppo, mi son reso conto che è necessario aggiornare la parte di model e gestione delle varie entità solo nel caso in cui si stia effettivamente giocando; per questa ragione il metodo handle prevede che nel caso in cui ci si trovi nel menù di pausa, o finale (vittoria o sconfitta), venga aggiornata solo la grafica, uscendo dal loop della funzione handle() e richiamando le opportune classi di grafica, e non venga aggiornata invece la logica di gioco, risparmiando memoria e processi inutili.

\subsubsection{Gestione di inizio gioco}

\begin{figure}[H]
\centering{}
\includegraphics[width=\textwidth]{img/game_start.jpg}
\caption{Rappresentazione UML della logica di inizio gioco.}
\end{figure}

\paragraph{Problema} Avviare una partita in maniera totalmente indipendente ed efficace in qualunque momento e stato dell’applicazione.

\paragraph{Soluzione} Per permettere che una nuova partita possa essere sempre iniziata quando viene premuto il tasto "Start Game" e selezionato il livello, ho implementato il costruttore del GameEngine, che richiama il costruttore del controller principale GameController, che richiama i costruttori di tutti gli altri controller, i quali provvedono eventualmente a creare le varie entità del gioco. Il costruttore di GameEngine viene richiamato nel metodo start() del WindowGame, nel quale il gioco entra ogni volta che dalla home, la StartGameView, viene premuto il tasto "Start Game" e selezionato il livello.

\subsubsection{Gestione di fine gioco}

\begin{figure}[H]
\centering{}
\includegraphics[width=\textwidth]{img/gameplay.jpg}
\caption{Rappresentazione UML della logica di fine gioco.}
\end{figure}

\paragraph{Problema} Controllare che il giocatore abbia perso o vinto una partita.

\paragraph{Soluzione} Per fare in modo che fosse verificata la condizione di vittoria e sconfitta e fosse aggiornato il Gamestate, effettuo dei controlli all'interno del metodo gameLoop() del gameEngine. Questi controlli vengono quindi eseguiti ogni volta che la funzione handle richiama il metodo gameLoop(). Questi if in particolare controllano tramite metodi implementati nei Controller, che la partita non sia vinta nè persa. Nel caso la partita sia vinta, metodo isWon() del WindowController, vero se tutte le finestre sono state aggiustate, il GameState viene messo a WIN, mentre se la partita è stata persa, metodo isAlive() del FelixController che è falso quando Felix viene colpito tre volte da un mattone, il GameState viene messo a GAMEOVER. La funzione handle è implementata in modo per cui se il GameState è GAMEOVER o WIN, smette di ciclare e richiama le opportune view. 

\subsubsection{Gestione dei mattoni}

\begin{figure}[H]
\centering{}
\includegraphics[width=\textwidth]{img/throw.jpg}
\caption{Rappresentazione UML della logica di spawn dei mattoni.}
\end{figure}

\paragraph{Problema} Gestione dello spawn dei mattoni durante la partita.

\paragraph{Soluzione} Per gestire la generazione delle entità mattoni durante la partita da parte del nemico (Ralph), ho implementato un Component da associare a Ralph, ThrowBrickComponent che estende la classe AbstractComponent. Quando ralph viene creato nell'EntityFactory, gli viene associato un ThrowBrickComponent, quando viene richiamato il metodo update del GameController(), delega al RalphController il compito di lanciare mattoni. In particolare nel RalphController ci sono due metodi per generare mattoni nelle posizioni della mano sinistra e della mano destra di Ralph ogni intervallo di tempo, il quale varia a seconda del livello selezionato. 
Questi metodi utilizzano il metodo addBricks() del ThrowBrickComponent di Ralph per generare questi nuovi mattoni, il quale li aggiunge alla lista di entità presente nel GamePerformance. Sempre nel GamePerformance è presennte un metodo getBricks() che restituisce, dell'intera lista di entità solo i mattoni. 

\chapter{Sviluppo}
\section{Testing automatizzato}

\section{Metodologie di lavoro}
Per sviluppare questo progetto, dopo alcuni incontri di gruppo, abbiamo clonato il repository git ognuno in locale, cosi da poterci lavorare individualmente.
Ci siamo confrontati per ogni dubbio e, ogni qualvolta fosse necessario, abbiamo realizzato i commit con le nostre aggiunte al progetto principale, tramite comandi pull e push.

\subsubsection{Golesano Giulia}
\begin{itemize}
    \item Mi sono occupata autonomamente di:
    \item Inserimento png e risorse per il gioco.
    \item Creazione dell'interfaccia di View.
    \item Creazione di interfaccia e implementazione di GamePerformance.
    \item Gestione degli input da tastiera
    \item Creazione dello sfondo di gioco
    \item Creazione dell'entità finestra, della griglia e dei componenti a esse connessi.
    \item Creazione dei Test relativi alle classi sopra elencate.
\end{itemize}

\section{Note di sviluppo}
\subsubsection{Golesano Giulia}
\begin{itemize}
\item Utilizzo di Optional
    \item Utilizzo di Stream e Lambda expressions
    \end{itemize}
\subsubsection{Rinchiuso Giovanni}
\begin{itemize}
\item Utilizzo di Stream e Lambda expressions, presenti in varie parti del codice, ecco un esempio: 
\url {https://github.com/giuliagolesano/OOP23-WIR/blob/main/src/main/java/it/unibo/view/impl/WindowGame.java#L396C13-L400C1}
\end{itemize}

\chapter{Commenti Finali}
\subsection{Autovalutazione e lavori futuri}
\subsubsection{Golesano Giulia}
Quando ho iniziato a lavorare al progetto mi sentivo molto spaesata e incapace, rispetto ad una reale applicazione di ciò che avevo studiato.
Man mano che i mesi andavano avanti, la possibilità di lavorarci con calma, durante le lezioni, senza la fretta della sessione di esami, mi ha reso sempre più consapevole di come le cose funzionavano e come potevo realizzare le mie idee.
Sento inoltre che mi è servito tanto il lavoro di gruppo con i miei compagni, perché ho appreso elasticità rispetto alle velocità e tecniche di lavoro degli altri.
In conclusione, penso che tutto il gruppo abbia fatto un discreto lavoro.
\subsubsection{Cornacchia Enrico}

\subsubsection{Rinchiuso Giovanni}
Inizialmente avevo molti timori riguardo a questo progetto, in quanto essendo uno studente al terzo anno, avevo bisogno di superare questo esame per potermi laureare. Inoltre tutti i miei compagni di corso mi hanno sempre parlato di questo progetto come il più stimolante ma anche come il più impegnativo che avessero affrontato. Questa cosa mi spaventava molto, perché credevo di non essere in grado di portarlo a termine, però mi ha anche aiutato ad affrontare questo progetto con il dovuto impegno. E' stato molto stimolante vedere che il nostro gioco diventava sempre più simile a come l'avevamo immaginato. Il gruppo ha lavorato molto bene, è stato gratificante poter contare sull'aiuto degli altri ed essere io stesso utile a loro. Penso che ci siano margini di miglioramento sia per la nostra applicazione, sia per il mio metodo di programmazione, ma penso di essere sulla strada giusta e che il lavoro svolto sia buono. 

\appendix
\chapter{Guida Utente}
L'obiettivo del gioco è aggiustare tutte le finestre, schivando i mattoni lanciati da Ralph e cercando di raggiungere tutti i power ups disponibili.
I comandi di gioco sono:
\begin{itemize}
 \item A: Movimento verso sinistra.
 \item W: Movimento verso l'alto.
 \item S: Movimento verso il basso.
 \item D: Movimento verso destra.
 \item Z: Se premuto per 1.5 secondi aggiusta la finestra in cui si trova Felix.
\end{itemize}
I power ups sono:
\begin{itemize}
 \item Cake: rende immortale Felix per 5 secondi
 \item Bird: Ralph non lancia più mattoni per un tempo variabile
\end{itemize}
\chapter{Esecitazioni di laboratorio} 

\subsection{enrico.cornacchia@studio.unibo.it}

\begin{itemize}
 \item Laboratorio 06: \url{https://virtuale.unibo.it/mod/forum/discuss.php?d=146511#p208416}
 \item Laboratorio 07: \url{https://virtuale.unibo.it/mod/forum/discuss.php?d=147598#p209350}
 \item Laboratorio 08: \url{https://virtuale.unibo.it/mod/forum/discuss.php?d=148025#p210126}
 \item Laboratorio 09: \url{https://virtuale.unibo.it/mod/forum/discuss.php?d=149231#p211607}
 \item Laboratorio 10: \url{https://virtuale.unibo.it/mod/forum/discuss.php?d=150252#p212636}
\end{itemize}

\end{document}
